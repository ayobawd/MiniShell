diff --git a/free_all.c b/free_all.c
index 5178720..6dac450 100644
--- a/free_all.c
+++ b/free_all.c
@@ -1,8 +1,20 @@
+/* ************************************************************************** */
+/*                                                                            */
+/*                                                        :::      ::::::::   */
+/*   free_all.c                                         :+:      :+:    :+:   */
+/*                                                    +:+ +:+         +:+     */
+/*   By: aradwan <aradwan@student.42.fr>            +#+  +:+       +#+        */
+/*                                                +#+#+#+#+#+   +#+           */
+/*   Created: 2025/01/XX XX:XX:XX by aradwan           #+#    #+#             */
+/*   Updated: 2025/01/XX XX:XX:XX by aradwan          ###   ########.fr       */
+/*                                                                            */
+/* ************************************************************************** */
+
 #include "minishell.h"
 
-static void free_redirects(t_cmds *cmd)
+static void	free_redirects(t_cmds *cmd)
 {
-	int i;
+	int	i;
 
 	i = 0;
 	while (i < cmd->red_len)
@@ -16,10 +28,10 @@ static void free_redirects(t_cmds *cmd)
 
 void	free_strings(char **av)
 {
-	int i;
+	int	i;
 
 	if (!av)
-		return;
+		return ;
 	i = 0;
 	while (av[i])
 		free(av[i++]);
@@ -28,7 +40,7 @@ void	free_strings(char **av)
 
 void	free_all(t_shell *pipe, t_cmds *cmd)
 {
-	int		i;
+	int	i;
 
 	if (pipe && pipe->cmds)
 	{
@@ -50,8 +62,6 @@ void	free_all(t_shell *pipe, t_cmds *cmd)
 		}
 		free(cmd);
 	}
-	// Don't free environment during normal operation
-	// Environment should only be freed at shell exit
 }
 
 void	free_environment(t_shell *pipe)
@@ -61,9 +71,6 @@ void	free_environment(t_shell *pipe)
 	while (pipe && pipe->environment)
 	{
 		tmp = pipe->environment->next;
-		// For dynamically allocated environment variables, we need to free content
-		// For original environment variables, they should not be freed
-		// To be safe, we assume all are dynamically allocated after modifications
 		if (pipe->environment->content)
 			free(pipe->environment->content);
 		free(pipe->environment);
diff --git a/minishell.c b/minishell.c
index 6fdffb5..29a91bd 100644
--- a/minishell.c
+++ b/minishell.c
@@ -12,37 +12,45 @@
 
 #include "minishell.h"
 
-int	main(int ac, char **av, char **env)
+static void	shell_loop(t_shell *s)
 {
-	char		*input;
-	t_shell		s;
-	t_cmds		*cmd;
+	char	*input;
+	t_cmds	*cmd;
 
-	(void)av;
-	if (ac != 1)
-		return (0);
-	copy_env(&s, env);
-	s.cmd_len = 0;
-	s.cmds = NULL;
 	while (1)
 	{
 		signal(SIGINT, handle_signals);
 		signal(SIGQUIT, SIG_IGN);
 		input = readline("minishell> ");
 		if (!input)
-			return (printf("exit\n"), 0);
+		{
+			printf("exit\n");
+			return ;
+		}
 		cmd = NULL;
-		if (parsing(&s, cmd, input))
+		if (parsing(s, cmd, input))
 		{
 			free(input);
 			continue ;
 		}
-		init_commands(&s, &cmd);
-		/* Execute the parsed commands */
-		g_exit_code = execute_commands(&s, cmd);
-		free_all(&s, cmd);
+		init_commands(s, &cmd);
+		g_exit_code = execute_commands(s, cmd);
+		free_all(s, cmd);
 		add_history(input);
 		free(input);
 	}
+}
+
+int	main(int ac, char **av, char **env)
+{
+	t_shell	s;
+
+	(void)av;
+	if (ac != 1)
+		return (0);
+	copy_env(&s, env);
+	s.cmd_len = 0;
+	s.cmds = NULL;
+	shell_loop(&s);
 	return (0);
 }
diff --git a/minishell.h b/minishell.h
index 4887204..5b468cc 100644
--- a/minishell.h
+++ b/minishell.h
@@ -159,7 +159,4 @@ void	rl_replace_line(const char *text, int clear_undo);
 void	rl_redisplay(void);
 void	quotes_check(char **str, t_variables *v);
 
-
-
-
 #endif
\ No newline at end of file
